---
title: "eDNA"
author: "Jay T. Lennon, Mario E. Muscarella, ..."
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
  - \usepackage{array}
output: pdf_document
geometry: margin=2.54cm
---

Analysis of community sequence data to test whether the structure and composition of bacterial communities is affected by extracellular DNA

# Setup Work Environment 
```{r}
# rm(list=ls())
getwd()
setwd("~/GitHub/eDNA/code")

# Load dependencies
require("vegan")
require("plyr")
require("grid")
require("png")
require("ape")
require("picante")
require("ade4")
#require("phytools")
require("phangorn")

# Source code functions
source("../bin/DiversityFunctions.R")
source("../bin/MothurTools.R")
source("../bin/phylodiversity2.R")

# Small custom functions
sem <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}

# Save Default Plot Settings
opar <- par(no.readonly = TRUE)  # Saves plot defaults
```

# Phylogenetic Diversity
A multi-fasta file was generated with representative sequences for each OTU. 
Representatives were picked based on the most abundant unique sequence in each OTU.
[FastTree](http://www.microbesonline.org/fasttree/) was used to construct a phylogenetic tree.
Note: This must be done before performing the following analyses.
The following parameters were used:

```{sh}
Note: eDNA.bac.final.0.03.rep.fasta is larger than the github limits. Please obtain the file from SDA or DC2

> FastTree -gtr -nt -gamma -fastest eDNA.bac.final.0.03.rep.rename.fasta >> eDNA.bac.rename.tree

Output: 
ML-NNI round 14: LogLk = -5469747.038 NNIs 18759 max delta 6.95 Time 4888.39 (final)ax delta 6.954)   
Optimize all lengths: LogLk = -5469663.971 Time 5006.96  
Gamma(20) LogLk = -5470984.148 alpha = 1.037 rescaling lengths by 1.659   
Total time: 5529.61 seconds Unique: 174292/174292 Bad splits: 903/174289 Worst delta-LogLk 10.311
```

# Define Inputs
```{r}
  # Design       = general design file for experiment
  # shared       = OTU table from mothur with sequence similarity clustering
  # tax          = Taxonomy for 97% similarity OTUs
design       <- "../data/eDNA_Design.txt"
shared       <- "../mothur/output/eDNA.bac.final.shared"
tax          <- "../mothur/output/eDNA.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.an.unique_list.0.03.cons.taxonomy"
```

# Import Design
```{r}
design <- read.delim(design, header=T, row.names=1)
```

# Import Shared, Taxonomy, and Phylogeny Files
```{r}
OTU <- read.otu(shared = shared, cutoff = "0.03")
OTU.tax <- read.tax(taxonomy = tax, format = "rdp")
OTU.tre <- read.tree("../mothur/output/eDNA.bac.rename.tree")
```

# Remove OTUs with less than two occurences across all sites
```{r}
OTU <- OTU[, which(colSums(OTU) >= 2)]
```

# Coverage Stats
```{r}
cov.seqs <- count.groups(OTU)
cov.mean <- mean(cov.seqs) # 222701
cov.sem <- sem(cov.seqs) # 9560
cov.min <- min(cov.seqs) # 31,475
total.seqs <- sum(cov.seqs) # 12,916,632

# Good's coverage 
goods.c <- function(x = ""){
              1 - (apply(OTU, 1, function(x){sum(x == 1)}) / rowSums(x))
           }
goods.c.eDNA <- goods.c(OTU)
mean.good.c <- mean(goods.c.eDNA) # 0.99
min.good.c <- min(goods.c.eDNA) # 0.98
```

# Alpha diversity
```{r}
# Mario's resampling to estimate alpha diversity in a sample (long)
#rich <- round(richness.iter(input = OTU, size = 30000,
#             iters = 100, shared = "FALSE"), 3)
#even <- round(evenness.iter(input = OTU, size = 30000,
#             iters = 100, shared = "FALSE", method = "simp_even"), 3)

# rarefy(OTU, sample, se = FALSE, MARGIN = 1)

# Write output to files
#write.table(rich, "../data/rich.txt", sep = "\t", col.names = T, row.names = T)
#write.table(even, "../data/even.txt", sep = "\t", col.names = T, row.names = T)

# Read in alpha diversity files from above
rich2 <- read.table("../data/rich.txt", sep = "\t")
even2 <- read.table("../data/even.txt", sep = "\t")

# Merge data to design and calculate mean and sem per sample
rich.data <- merge(design, rich2, by = "row.names")
row.names(rich.data) <- rich.data$Row.names
rich.data <- rich.data[sort(row.names(rich.data)), ]
rich.mean <- round(apply(rich.data[8:(7 + dim(rich2)[2])], 1, mean, na.rm = TRUE),3)
rich.sem <- round(apply(rich.data[8:(7 + dim(rich2)[2])], 1, sem, na.rm = TRUE), 3)


even.data <- merge(design, even2, by = "row.names")
row.names(even.data) <- even.data$Row.names
even.data <- even.data[sort(row.names(even.data)), ]
even.mean <- round(apply(even.data[8:(7 + dim(even2)[2])], 1, mean, na.rm = TRUE),3)
even.sem <- round(apply(even.data[8:(7 + dim(even2)[2])], 1, sem, na.rm = TRUE),4)


# Make new dataframe merging design file and mean diversity
eDNA.div <- data.frame(design[sort(row.names(design)), ], rich.mean, even.mean)

# Take averages of technial reps
rich.rep.ave <- ddply(eDNA.div, .(env, treat, qPCR.match), summarize, rich = mean(rich.mean))
even.rep.ave <- ddply(eDNA.div, .(env, treat, qPCR.match), summarize, even = mean(even.mean))

# Reshape data
rich.2 <- reshape(rich.rep.ave[,1:4], timevar = "treat", 
                   idvar = c("qPCR.match", "env"), direction = "wide")

even.2 <- reshape(even.rep.ave[,1:4], timevar = "treat", 
                   idvar = c("qPCR.match", "env"), direction = "wide")
```

# Richness: does eDNA "inflate" diversity?
```{r}
# Take averages of technial reps
rich.rep.ave <- ddply(eDNA.div, .(env, treat, qPCR.match), 
                      summarize, rich = mean(rich.mean))

# Reshape data
rich.2 <- reshape(rich.rep.ave[,1:4], timevar = "treat", 
                   idvar = c("qPCR.match", "env"), direction = "wide")

# Calculate ratios
rich.2$rich.ratio <- rich.2$rich.E / rich.2$rich.C

# Richness table
rich.2.ag.mean <- aggregate(rich.ratio ~ env, rich.2, mean)
rich.2.ag.sem <- aggregate(rich.ratio ~ env, rich.2, sem)
rich.2.ag.95 <- aggregate(rich.ratio ~ env, rich.2, 
                  FUN = function(x) t.test(x)$conf.int[1:2])
rich.table <- data.frame(rich.2.ag.mean$env, rich.2.ag.mean$rich.ratio,
                         rich.2.ag.sem$rich.ratio, rich.2.ag.95$rich.ratio)
colnames(rich.table) <- c("env", "mean", "sem", "LCI", "UCI")


# Regression: richness ratio vs. proportion eDNA
eDNA.prop <- read.table("../data/eDNA.prop.txt", sep = "\t", header = T)

# The following is not needed
## sample.list <- paste(as.character(rich.2$qPCR.match), collapse=", ")
## eDNA.prop.sub<-eDNA.prop[eDNA.prop$sample.number %in% c(30, 31, 33, 34, 2, 7, 11, 
##                  13, 15, 16, 5, 6, 26, 27, 29, 3, 10, 12, 14, 17, 20),]

eDNA.prop.sub <- eDNA.prop[eDNA.prop$sample.number %in% rich.2$qPCR.match, ]

eDNA.prop.sub2 <- eDNA.prop.sub[order(eDNA.prop.sub$sample.number), ] 
rich.reg <- lm(rich.2[order(rich.2$qPCR.match), ]$rich.ratio ~ eDNA.prop.sub2$env + eDNA.prop.sub2$prop)

summary(rich.reg)
Anova(rich.reg)
# answer => no correlation between proportion eDNA and richness ratio. 
# maybe a little in sediment
```

# Evenness: does eDNA "inflate" diversity?
```{r}
# Take averages of technial reps
even.rep.ave <- ddply(eDNA.div, .(env, treat, qPCR.match), 
                      summarize, even = mean(even.mean))

# Reshape data
even.2 <- reshape(even.rep.ave[,1:4], timevar = "treat", 
                   idvar = c("qPCR.match", "env"), direction = "wide")

# Calculate ratios
even.2$even.ratio <- even.2$even.E / even.2$even.C

# Evennes table
even.2.ag.mean <- aggregate(even.ratio ~ env, even.2, mean)
even.2.ag.sem <- aggregate(even.ratio ~ env, even.2, sem)
even.2.ag.95 <- aggregate(even.ratio ~ env, even.2, 
                  FUN = function(x) t.test(x)$conf.int[1:2])
even.table <- data.frame(even.2.ag.mean$env, even.2.ag.mean$even.ratio,
                         even.2.ag.sem$even.ratio, even.2.ag.95$even.ratio) 
colnames(even.table) <- c("env", "mean", "sem", "LCI", "UCI")


# Regression: evennes ratio vs. proportion eDNA
even.reg <- lm(even.2[order(even.2$qPCR.match), ]$even.ratio ~ eDNA.prop.sub2$prop + eDNA.prop.sub2$env )
summary(even.reg) 
# answer => no correlation between proportion eDNA and evenness ratio. 
```

# Richness plot
```{r}
png(filename="../figures/ratio.richness.png",
    width = 800, height = 600, res = 96*2)

par(mar=c(3, 4, 1, 1) + 0.1)

rich.plot <- plot(rich.table$mean, ylim = c(0.5, 1.5), 
      xlim = c(0.5, 4.5), pch = 22, bg = "white", lwd = 2, 
      cex = 3, yaxt = "n", xaxt = "n", cex.lab = 2, cex.axis = 1.5, 
      las = 1, ylab = "", xlab = "")
      box(lwd = 2) 
abline(h = 1, lty = 3, lwd = 2)
arrows(x0 = c(1,2,3,4), y0 = rich.table$mean, y1 = rich.table$LCI, angle = 90,
       length = 0.1, lwd = 2)
arrows(x0 = c(1,2,3,4), y0 = rich.table$mean, y1 = rich.table$UCI, angle = 90,
       length=0.1, lwd = 2)
points(c(1:4), rich.table$mean,pch = 22, cex = 3, bg = "gray90", lwd = 2)

mtext(expression('Richness Ratio'), side = 2, 
      outer = F, cex = 1.5, line = 2.5, adj = 0.5)  

# Major Axes
axis(side = 2, lwd.ticks = 2, cex.axis = 1, las = 1,
    labels = T, at = c(0.5, 1, 1.5))
axis(side = 4, lwd.ticks = 2, cex.axis = 1, las = 1,
   labels = F, at = c(0.5, 1, 1.5))
axis(side = 1, lwd.ticks = 2, cex.axis = 0.9, las = 1,
    labels = c("Gut", "Sediment", "Soil", "Water"), at = c(1, 2, 3, 4)) 
axis(side = 3, lwd.ticks = 2, cex.axis = 1.5, las = 1,
    at = c(1, 2, 3, 4), labels = F) 

# Minor ticks
axis(side = 2, lwd.ticks = 2, tck = 0.02, labels = F, at = c(0.5, 1, 1.5))
axis(side = 4, lwd.ticks = 2, tck = 0.02, labels = F, at = c(0.5, 1, 1.5))
axis(side = 1, lwd.ticks = 2, tck = 0.02, labels = F, at = c(1, 2, 3, 4))
axis(side = 3, lwd.ticks = 2, tck = 0.02, labels = F, at = c(1, 2, 3, 4))

# Close Plot Device
dev.off()
graphics.off()

# Show Plot
img <- readPNG("../figures/ratio.richness.png")
grid.raster(img)
```

# Evenness plot
```{r}
png(filename="../figures/ratio.evenness.png",
    width = 800, height = 600, res = 96*2)

par(mar=c(3, 4, 1, 1) + 0.1)

even.plot <- plot(even.table$mean, ylim = c(0.5, 1.5), 
      xlim = c(0.5, 4.5), pch = 22, bg = "white", lwd = 2, 
      cex = 3, yaxt = "n", xaxt = "n", cex.lab = 2, cex.axis = 1.5, 
      las = 1, ylab = "", xlab = "")
      box(lwd = 2)
abline(h = 1, lty = 3, lwd = 2)
arrows(x0 = c(1,2,3,4), y0 = even.table$mean, y1 = even.table$LCI, angle = 90,
       length = 0.1, lwd = 2)
arrows(x0 = c(1,2,3,4), y0 = even.table$mean, y1 = even.table$UCI, angle = 90,
       length=0.1, lwd = 2)
points(c(1:4), even.table$mean,pch = 22, cex = 3, bg = "gray90", lwd = 2)

mtext(expression('Evenness Ratio'), side = 2, 
        outer = F, cex = 1.5, line = 2.5, adj = 0.5)
# Major Axes
axis(side = 2, lwd.ticks = 2, cex.axis = 1, las = 1,
    labels = T, at = c(0.5, 1, 1.5))
 
axis(side = 4, lwd.ticks = 2, cex.axis = 1, las = 1,
   labels = F, at = c(0.5, 1, 1.5))

axis(side = 1, lwd.ticks = 2, cex.axis = 0.9, las = 1,
    labels = c("Gut", "Sediment", "Soil", "Water"), at = c(1, 2, 3, 4))

axis(side = 3, lwd.ticks = 2, cex.axis = 1.5, las = 1,
    at = c(1, 2, 3, 4), labels = F)

# Minor ticks
axis(side = 2, lwd.ticks = 2, tck = 0.02, labels = F, at = c(0.5, 1, 1.5))
axis(side = 4, lwd.ticks = 2, tck = 0.02, labels = F, at = c(0.5, 1, 1.5))
axis(side = 1, lwd.ticks = 2, tck = 0.02, labels = F, at = c(1, 2, 3, 4))
axis(side = 3, lwd.ticks = 2, tck = 0.02, labels = F, at = c(1, 2, 3, 4))

# Close Plot Device
dev.off()
graphics.off()

# Show Plot
img <- readPNG("../figures/ratio.evenness.png")
grid.raster(img)
```


# Phylogenetic Diversity: does eDNA "inflate" diversity?
```{r}
# Test if all OTUs are in tree
sum(colnames(OTU) %in% OTU.tre$tip.label) == length(colnames(OTU) %in% OTU.tre$tip.label)

# Root Tree if Needed
is.rooted(OTU.tre)
OTU.tre.rooted <- midpoint(OTU.tre)

#OTU.2 <- rrarefy(OTU, 30000)
#OTU.2 <- OTU.2[,which(colSums(OTU.2) > 0)]
#OTU.tre.2 <- prune.sample(OTU.2, OTU.tre.rooted)

# Calculate Faith's D
#eDNA.pd <- pd(OTU.2, OTU.tre.2, include.root = F)

# Write output to files
#write.table(eDNA.pd, "../data/phylo.txt", sep = "\t", col.names = T, row.names = T)

# Read in alpha diversity files from above
eDNA.pd2 <- read.table("../data/phylo.txt", sep = "\t")

# Make new dataframe merging design file and phylo diversity
eDNA.phylo <- data.frame(design[sort(row.names(design)), ], pd = eDNA.pd2$PD)

# Take averages of technial reps
pd.rep.ave <- ddply(eDNA.phylo, .(env, treat, qPCR.match), 
                      summarize, phylo = mean(pd))

# Reshape data
phylo.2 <- reshape(pd.rep.ave[,1:4], timevar = "treat", 
                   idvar = c("qPCR.match", "env"), direction = "wide")

# Calculate ratios
phylo.2$phylo.ratio <- phylo.2$phylo.E / phylo.2$phylo.C

# Richness table
phylo.2.ag.mean <- aggregate(phylo.ratio ~ env, phylo.2, mean)
phylo.2.ag.sem <- aggregate(phylo.ratio ~ env, phylo.2, sem)
phylo.2.ag.95 <- aggregate(phylo.ratio ~ env, phylo.2, 
                  FUN = function(x) t.test(x)$conf.int[1:2])
phylo.table <- data.frame(phylo.2.ag.mean$env, phylo.2.ag.mean$phylo.ratio,
                         phylo.2.ag.sem$phylo.ratio, phylo.2.ag.95$phylo.ratio)
colnames(phylo.table) <- c("env", "mean", "sem", "LCI", "UCI")


# Regression: PD ratio vs. proportion eDNA
phylo.reg <- lm(phylo.2[order(phylo.2$qPCR.match), ]$phylo.ratio ~ eDNA.prop.sub2$prop * eDNA.prop.sub2$env )
summary(phylo.reg) 
# answer => no correlation between proportion eDNA and evenness ratio. 

```

# Faith's D plot
```{r}
png(filename="../figures/ratio.phylo.png",
    width = 800, height = 600, res = 96*2)

par(mar=c(3, 4, 1, 1) + 0.1)

phylo.plot <- plot(phylo.table$mean, ylim = c(0.5, 1.5), 
      xlim = c(0.5, 4.5), pch = 22, bg = "white", lwd = 2, 
      cex = 3, yaxt = "n", xaxt = "n", cex.lab = 2, cex.axis = 1.5, 
      las = 1, ylab = "", xlab = "")
      box(lwd = 2)
abline(h = 1, lty = 3, lwd = 2)
arrows(x0 = c(1,2,3,4), y0 = phylo.table$mean, y1 = phylo.table$LCI, angle = 90,
       length = 0.1, lwd = 2)
arrows(x0 = c(1,2,3,4), y0 = phylo.table$mean, y1 = phylo.table$UCI, angle = 90,
       length=0.1, lwd = 2)
points(c(1:4), phylo.table$mean,pch = 22, cex = 3, bg = "gray90", lwd = 2)

mtext(expression('Faiths D Ratio'), side = 2, 
        outer = F, cex = 1.5, line = 2.5, adj = 0.5)
# Major Axes
axis(side = 2, lwd.ticks = 2, cex.axis = 1, las = 1,
    labels = T, at = c(0.5, 1, 1.5))
 
axis(side = 4, lwd.ticks = 2, cex.axis = 1, las = 1,
   labels = F, at = c(0.5, 1, 1.5))

axis(side = 1, lwd.ticks = 2, cex.axis = 0.9, las = 1,
    labels = c("Gut", "Sediment", "Soil", "Water"), at = c(1, 2, 3, 4))

axis(side = 3, lwd.ticks = 2, cex.axis = 1.5, las = 1,
    at = c(1, 2, 3, 4), labels = F)

# Minor ticks
axis(side = 2, lwd.ticks = 2, tck = 0.02, labels = F, at = c(0.5, 1, 1.5))
axis(side = 4, lwd.ticks = 2, tck = 0.02, labels = F, at = c(0.5, 1, 1.5))
axis(side = 1, lwd.ticks = 2, tck = 0.02, labels = F, at = c(1, 2, 3, 4))
axis(side = 3, lwd.ticks = 2, tck = 0.02, labels = F, at = c(1, 2, 3, 4))

# Close Plot Device
dev.off()
graphics.off()

# Show Plot
img <- readPNG("../figures/ratio.phylo.png")
grid.raster(img)
```


# Beta diversity
```{r}
# Make presence-absence matrix
OTU.PA <- (OTU > 0) * 1

# Make relative abundence matrix
OTU.REL <- OTU
for (i in 1:dim(OTU)[1]){
  OTU.REL[i,] <- OTU[i,]/sum(OTU[i,])
  }

# Log-transform relative abundances
OTU.REL.log <- decostand(OTU, method="log")

eDNA.bc.dis <- vegdist(OTU.REL.log, method = "bray", binary = "FALSE")
eDNA.dis.mean <- mean(eDNA.bc.dis)

# Principal Coordinates Analysis (PCoA)
eDNA.PCoA <- cmdscale(eDNA.bc.dis, eig = TRUE, k = 3) 
explainvar1 <- round(eDNA.PCoA$eig[1] / sum(eDNA.PCoA$eig), 3) * 100
explainvar2 <- round(eDNA.PCoA$eig[2] / sum(eDNA.PCoA$eig), 3) * 100
explainvar3 <- round(eDNA.PCoA$eig[3] / sum(eDNA.PCoA$eig), 3) * 100
sum.eig <- sum(explainvar1, explainvar2, explainvar3)

# OTU Scores
otu.scores <- t(cor(eDNA.PCoA$points, OTU.REL))
otu.scores <- as.matrix(otu.scores)[,1:2]
otu.scores <- otu.scores[abs(otu.scores[,1]) > 0.7|abs(otu.scores[,2]) > 0.7,]
```

## PcoA Plot
```{r, results = "hide"}
png(filename="../figures/ordination.png",
    width = 1200, height = 800, res = 96*2)
layout(matrix(1:2, 1, 2), widths = c(9, 3))
par(mar = c(4, 5, 1, 0) + 0.5)

plot(eDNA.PCoA$points[ ,1], eDNA.PCoA$points[ ,2], 
     ylim = c(-0.4, 0.4), xlim = c(-0.5, 0.4), 
     xlab = paste("PCoA 1 (", explainvar1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", explainvar2, "%)", sep = ""),
     #xlab = "", ylab = "", xaxt = "n", yaxt = "n",
     pch = 22, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1, 
     axes = FALSE) 

# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.25, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.25, las = 1)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 1, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 2, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

# Subset data
eDNA.div.sort <- eDNA.div[order(eDNA.div[,1]) ,]
all.equal(row.names(eDNA.PCoA$points), rownames(eDNA.div.sort))
eDNA.points <- data.frame(eDNA.PCoA$points, eDNA.div.sort)

# Gut
eDNA.gut.C <- eDNA.points[ which(eDNA.points$env == "feces" & eDNA.points$treat == "C"), ]
eDNA.gut.E <- eDNA.points[ which(eDNA.points$env == "feces" & eDNA.points$treat == "E"), ]

# Sed
eDNA.sed.C <- eDNA.points[ which(eDNA.points$env == "sed" & eDNA.points$treat == "C"), ]
eDNA.sed.E <- eDNA.points[ which(eDNA.points$env == "sed" & eDNA.points$treat == "E"), ]

# Soil
eDNA.soil.C <- eDNA.points[ which(eDNA.points$env == "soil" & eDNA.points$treat == "C"), ]
eDNA.soil.E <- eDNA.points[ which(eDNA.points$env == "soil" & eDNA.points$treat == "E"), ]

# Water
eDNA.water.C <- eDNA.points[ which(eDNA.points$env == "water" & eDNA.points$treat == "C"), ]
eDNA.water.E <- eDNA.points[ which(eDNA.points$env == "water" & eDNA.points$treat == "E"), ]

# Add points

# Gut C
points(eDNA.gut.C[ ,1], eDNA.gut.C[ ,2], pch = 21, cex = 2, col = "red", 
       bg = "white", lwd = 2) 
# Gut E
points(eDNA.gut.E[ ,1], eDNA.gut.E[ ,2], pch = 21, cex = 2, col = "red", 
       bg = "red", lwd = 2)   

# Sed C
points(eDNA.sed.C[ ,1], eDNA.sed.C[ ,2], pch = 22, cex = 2, col = "darkgreen", 
       bg = "white", lwd = 2) 
# Sed E
points(eDNA.sed.E[ ,1], eDNA.sed.E[ ,2], pch = 22, cex = 2, col = "darkgreen", 
       bg = "darkgreen", lwd = 2) 

# Soil C
points(eDNA.soil.C[ ,1], eDNA.soil.C[ ,2], pch = 24, cex = 2, col = "brown", 
       bg = "white", lwd = 2) 
# Soil E
points(eDNA.soil.E[ ,1], eDNA.soil.E[ ,2], pch = 24, cex = 2, col = "brown", 
       bg = "brown", lwd = 2) 

# Water C
points(eDNA.water.C[ ,1], eDNA.water.C[ ,2], pch = 23, cex = 2, col = "blue", 
       bg = "white", lwd = 2) 
# Soil E
points(eDNA.water.E[ ,1], eDNA.water.E[ ,2], pch = 23, cex = 2, col = "blue", 
       bg = "blue", lwd = 2) 

# Add Legend Outside
par(mar = c(4, 0, 1, 1) + 0.5)
plot.new()
legend(0, 1, c("Gut", "Sediment", "Soil", "Water"), 
       pch = c(21, 22, 24, 23), pt.bg = c("red", "darkgreen", "brown", "blue"), 
       bty = "n", y.intersp = 1.5)
legend(0, 0.25, c("Control", "DNase"), pch = 22, pt.bg = c("white", "black"),
       bty = "n", y.intersp = 1.5)

# Close Plot Device
dev.off()
graphics.off()

# Show Plot
img <- readPNG("../figures/ordination.png")
grid.raster(img)
```

# PERMANOVA
```{r}
# Check Order of Dataframes
all.equal(row.names(eDNA.div), row.names(OTU.REL.log))

eDNA.permanova <- adonis(OTU.REL.log ~ eDNA.div$env * eDNA.div$treat, 
                         method = "bray", binary = FALSE)
eDNA.permanova

eDNA.bc.dis <- vegdist(OTU.REL.log, method = "bray", binary = "FALSE")
beta.disp <- betadisper(d = eDNA.bc.dis, group = eDNA.div$env)
permutest(beta.disp, 99)
TukeyHSD(beta.disp)
```

# Mantel Test 
```{r}
# Check order of design
all.equal(row.names(eDNA.div), row.names(OTU.REL.log))

OTU.REL.c <- OTU.REL.log[which(eDNA.div$treat == "C"), ]
OTU.REL.e <- OTU.REL.log[which(eDNA.div$treat == "E"), ]

eDNA.div.c <- eDNA.div[which(eDNA.div$treat == "C"), ]
eDNA.div.e <- eDNA.div[which(eDNA.div$treat == "E"), ]

all.equal(sort(eDNA.div.c$samp.code), sort(eDNA.div.e$samp.code))

OTU.REL.c2 <- OTU.REL.c[order(eDNA.div.c$samp.code), ]
OTU.REL.e2 <- OTU.REL.e[order(eDNA.div.e$samp.code), ]

dist.c <- vegdist(OTU.REL.c2, "bray") 
dist.e <- vegdist(OTU.REL.e2, "bray") 

mantel.rtest(dist.c, dist.e, nrepet = 999)
```

# Distances between pairs (Distance Ratio)
```{r}
# Data Check
all.equal(row.names(eDNA.div), row.names(OTU.REL.log))

# Create Raw Distance Matrix
dist.raw <- vegdist(OTU.REL.log, method = "bray", upper = T, diag = T)

# Separate by Treatments
eDNA.div.c <- eDNA.div[which(eDNA.div$treat == "C"), ]
eDNa.div.e <- eDNA.div[which(eDNA.div$treat == "C"), ]
OTU.REL.log.c <- OTU.REL.log[which(eDNA.div$treat == "C"), ]
OTU.REL.log.e <- OTU.REL.log[which(eDNA.div$treat == "E"), ]

# Order Each by Pairings
eDNA.div.c <- eDNA.div.c[order(eDNA.div.c$pair), ]
eDNA.div.e <- eDNA.div.e[order(eDNA.div.e$pair), ]
OTU.REL.log.c <- OTU.REL.log.c[order(eDNA.div.c$pair), ]
OTU.REL.log.e <- OTU.REL.log.e[order(eDNA.div.e$pair), ]
all.equal(eDNA.div.e$env, eDNA.div.c$env)

# Create Distance Matrix for Treatments
dist.c <- vegdist(OTU.REL.log.c, method = "bray", upper = T, diag = T)
dist.e <- vegdist(OTU.REL.log.e, method = "bray", upper = T, diag = T)

# Turn Distance Matrices into Matrices
dist.raw <- as.matrix(dist.raw)
dist.e <- as.matrix(dist.e)
dist.c <- as.matrix(dist.c)

# Seperate by Habitat
eDNA.div.gut <- eDNA.div[which(eDNA.div$env == "feces"), ]
eDNA.div.sed <- eDNA.div[which(eDNA.div$env == "sed"), ]
eDNA.div.sol <- eDNA.div[which(eDNA.div$env == "soil"), ]
eDNA.div.wat <- eDNA.div[which(eDNA.div$env == "water"), ]

OTU.REL.log.gut <- OTU.REL.log[which(eDNA.div$env == "feces"), ]
OTU.REL.log.sed <- OTU.REL.log[which(eDNA.div$env == "sed"), ]
OTU.REL.log.sol <- OTU.REL.log[which(eDNA.div$env == "soil"), ]
OTU.REL.log.wat <- OTU.REL.log[which(eDNA.div$env == "water"), ]

# Order Each by Pairings
eDNA.div.gut <- eDNA.div.gut[order(eDNA.div.gut$pair), ]
eDNA.div.sed <- eDNA.div.sed[order(eDNA.div.sed$pair), ]
eDNA.div.sol <- eDNA.div.sol[order(eDNA.div.sol$pair), ]
eDNA.div.wat <- eDNA.div.wat[order(eDNA.div.wat$pair), ]
OTU.REL.log.gut <- OTU.REL.log.gut[order(eDNA.div.gut$pair), ]
OTU.REL.log.sed <- OTU.REL.log.sed[order(eDNA.div.sed$pair), ]
OTU.REL.log.sol <- OTU.REL.log.sol[order(eDNA.div.sol$pair), ]
OTU.REL.log.wat <- OTU.REL.log.wat[order(eDNA.div.wat$pair), ]

# Create Distance Matrix for Treatments
dist.gut <- vegdist(OTU.REL.log.gut, method = "bray", upper = F, diag = F)
dist.sed <- vegdist(OTU.REL.log.sed, method = "bray", upper = F, diag = F)
dist.sol <- vegdist(OTU.REL.log.sol, method = "bray", upper = F, diag = F)
dist.wat <- vegdist(OTU.REL.log.wat, method = "bray", upper = F, diag = F)

# Turn Distance Matrices into Matrices
dist.gut2 <- as.matrix(dist.gut)
dist.sed2 <- as.matrix(dist.sed)
dist.sol2 <- as.matrix(dist.sol)
dist.wat2 <- as.matrix(dist.wat)

# what are the factors I have to work with
head(eDNA.div.gut)
levels(eDNA.div.gut$treat)
levels(as.factor(eDNA.div.gut$qPCR.match))

# Variance Partitioning
var.gut <- varpart(Y = dist.gut, as.numeric(eDNA.div.gut$treat), (eDNA.div.gut$qPCR.match))
plot(var.gut)

gut.RDA <- capscale(dist.gut ~ eDNA.div.gut$treat + as.factor(eDNA.div.gut$qPCR.match))
anova(gut.RDA, by = "term")
RsquareAdj(gut.RDA)

# Adjusted RSquare by Terms
rda.aov <- (anova(gut.RDA, by = "term"))
r2 <- (rda.aov$SumOfSqs[1:2] / sum(rda.aov$SumOfSqs[1:3]))
m <- c(length(levels(eDNA.div.gut$treat)) - 1, 
       length(levels(as.factor(eDNA.div.gut$qPCR.match))) - 1)
n <- nrow(gut.RDA$CCA$u)
adjr2 <- 1 - (1 - r2) * (n - 1)/(n - m - 1)
r2; adjr2; sum(r2); sum(adjr2)


var.r2 <- as.data.frame(matrix(NA, 4, 3))
colnames(var.r2) <- c("eDNA", "replicates", "unexplained")
row.names(var.r2) <- c("gut", "sed", "sol", "wat")
for (i  in 1:dim(var.r2)[1]){
  env.temp <- rownames(var.r2)[i]
  dis.temp <- get(paste("dist", env.temp, sep = "."))
  dat.temp <- get(paste("eDNA.div", env.temp, sep = "."))
  rda.temp <- capscale(dis.temp ~ dat.temp$treat + as.factor(dat.temp$qPCR.match))
  aov.temp <- anova(rda.temp, by = "term")
  r2 <- (aov.temp$SumOfSqs[1:2] / sum(aov.temp$SumOfSqs[1:3]))  
  var.r2[i, 1] <- r2[1]
  var.r2[i, 2] <- r2[2]
  var.r2[i, 3] <- (1 - sum(r2))
}
```


```{r, results = 'hide'}
png(filename="../figures/variation.png",
    width = 1200, height = 800, res = 96*2)
layout(matrix(1:2, 2, 1) , heights = c(8, 2))
par(mar = c(2, 5, 1, 0) + 0.5, oma = c(0.5, 0.5, 0.5, 0.5))

barplot(t(as.matrix(var.r2)),
        names.arg = c("Gut", "Sediment", "Soil", "Water"),
        las = 1, ylab = "")

mtext("Proportion of Variation", side = 2, cex = 1.25, line = 3)

# Add Legend Outside
par(mar = c(1, 5, 0, 1) + 0.5)
plot.new()
legend("top", c("DNase", "Replicates", "Unexplained"), 
       pch = 22, pt.bg = c("gray40", "gray60", "gray90"),
      bty = "n", y.intersp = 1.5, horiz = T)


# Close Plot Device
dev.off()
graphics.off()

# Show Plot
img <- readPNG("../figures/variation.png")
grid.raster(img)
```

# Variation based on Bray Curtis Distance
```{r}
bc.var <- as.data.frame(matrix(NA, 4, 3))
colnames(bc.var) <- c("reps", "treat", "env")
row.names(bc.var) <- c("gut", "sed", "sol", "wat")
for (i  in 1:dim(bc.var)[1]){
  env.temp <- rownames(bc.var)[i]
  dis.temp <- get(paste("dist", env.temp, sep = "."))
  dat.temp <- get(paste("eDNA.div", env.temp, sep = "."))
  dat.temp <- dat.temp[order(dat.temp$samp.num), ]
  if (all(attributes(dis.temp)$Labels != rownames(dat.temp))){
    stop("distance matix and data are not arranged properly")
  }
  dis.temp.C <- as.matrix(dis.temp)[which(dat.temp$treat == "C"), 
                                    which(dat.temp$treat == "C")]
  dis.temp.C <- as.dist(dis.temp.C)
  bc.var[i,3] <- mean(dis.temp.C)
  dis.pair <- as.data.frame(matrix(NA, length(unique(dat.temp$pair)), 3))
  colnames(dis.pair) <- c("C", "E", "dis")
  dis.pair[,1] <- rownames(dat.temp)[dat.temp$treat == "C"]
  for (j in 1:length(dis.pair$C)){
    pair <- dat.temp$pair[which(rownames(dat.temp) == dis.pair$C[j])]
    dis.pair[j, 2] <- rownames(dat.temp)[which(dat.temp$treat == "E" & 
                                         dat.temp$pair == pair)]
    dis.pair[j, 3] <- as.matrix(dis.temp)[which(rownames(dat.temp) == dis.pair[j, 1]), 
                                    which(rownames(dat.temp) == dis.pair[j, 2])]
  }
  bc.var[i,2] <- mean(dis.pair[,3])
  reps <- names(which(table(dat.temp$qPCR.match) > 2))
  dis.rep <- as.data.frame(matrix(NA, length(reps), 3))
  colnames(dis.rep) <- c("rep1", "rep2", "dis")
  for (k in 1:length(reps)){
    dis.rep[k, 1:2] <- rownames(dat.temp)[which(dat.temp$treat == "C" &
                                          dat.temp$qPCR.match == reps[k])]
    dis.rep[k, 3] <- as.matrix(dis.temp)[which(rownames(dat.temp) == dis.rep[k, 1]), 
                                    which(rownames(dat.temp) == dis.rep[k, 2])]
  }
  bc.var[i, 1] <- mean(dis.rep[, 3])
}

bc.var

bc.var <- bc.var/rowSums(bc.var)
    
```

```{r, results = 'hide'}
png(filename="../figures/BC_dist.png",
    width = 1200, height = 800, res = 96*2)
layout(matrix(1:2, 2, 1) , heights = c(8, 2))
par(mar = c(2, 5, 1, 0) + 0.5, oma = c(0.5, 0.5, 0.5, 0.5))

barplot(t(as.matrix(bc.var)),
        names.arg = c("Gut", "Sediment", "Soil", "Water"),
        las = 1, ylab = "", ylim = c(0, 1))

mtext("Bray Curtis Distance", side = 2, cex = 1.25, line = 3)

# Add Legend Outside
par(mar = c(1, 5, 0, 1) + 0.5)
plot.new()
legend("top", c("Replicates", "Treatments", "Environments"), 
       pch = 22, pt.bg = c("gray40", "gray60", "gray90"),
      bty = "n", y.intersp = 1.5, horiz = T)


# Close Plot Device
dev.off()
graphics.off()

# Show Plot
img <- readPNG("../figures/BC_dist.png")
grid.raster(img)
```

# Standardized BC distances
```{r}
bc.var.std <- bc.var/rowSums(bc.var)




```








#```{r}

# Mario's Stopping Point on 30 Sep 2016

dist.pair <- as.data.frame(matrix(NA, dim(design.c)[1], 2))
colnames(dist.pair) <- c("distance", "env")
for (i in 1:dim(design.c)[1]){
  dist.pair[i, 1] <- dist.raw[row.names(design.e)[i], row.names(design.c)[i]]
  dist.pair[i, 2] <- as.character(design.c[i, 3])
} 

pair.mean <- aggregate(distance ~ env, dist.pair, mean)
pair.sem <- aggregate(distance ~ env, dist.pair, sem)

dist.raw.c <- dist.raw[which(design2$treat == "C"), which(design2$treat == "C")]
design2.c <- design2[design2$treat == "C", ]

dist.feces <- dist.raw.c[which(design2.c$env == "feces"),which(design2.c$env == "feces")]
dist.feces.m <- mean(dist.feces[lower.tri(dist.feces)])

dist.soil <- dist.raw.c[which(design2.c$env == "soil"),which(design2.c$env == "soil")]
dist.soil.m <- mean(dist.soil[lower.tri(dist.soil)])

dist.sed <- dist.raw.c[which(design2.c$env == "sed"),which(design2.c$env == "sed")]
dist.sed.m <- mean(dist.sed[lower.tri(dist.sed)])

dist.water <- dist.raw.c[which(design2.c$env == "water"),which(design2.c$env == "water")]
dist.water.m <- mean(dist.water[lower.tri(dist.water)])

dist.env <- c(dist.feces.m, dist.soil.m, dist.sed.m, dist.water.m)
```


#```{r}

par(mar = c(5, 8, 1, 1) + 0.5)
plot(pair.mean$distance, 1:4, type = "n",
     xlim = c(0, 1), ylim = c(0.5, 4.5), axes = F,
     xlab = "", ylab = "")


arrows(y0 = 1:4, x0 = pair.mean$distance, 
       x1 = pair.mean$distance - pair.sem$distance, 
       angle = 90, length = 0.1, lwd = 2)
arrows(y0 = 1:4, x0 = pair.mean$distance, 
       x1 = pair.mean$distance + pair.sem$distance, 
       angle = 90, length = 0.1, lwd = 2)
points(pair.mean$distance, 1:4, cex = 3, pch = 22, 
       lwd = 2, col = "black", bg = "gray90")
abline(v = dist.env, lwd = 2, lty = 3)

axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.25, las = 1)
axis(side = 2, at = c(1:4), labels = c("Water", "Soil", "Sediment", "Feces"), lwd.ticks = 2, cex.axis = 1.25, las = 1)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 1, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 2, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)

mtext("Environment", side = 2, cex = 1.5, line = 6)
mtext("Pair Dissimilarity", side = 1, cex = 1.5, line = 3)

rect(0.55, 0.6, 0.9, 1.3, col = "white", border = NA)
text(dist.env, y = 0.9, labels = c("feces", "soil", "sed", "water"), 
     srt = 90, cex = 0.8)

legend("topleft", "Avg. Env. Dis.", lty = 3, lwd = 1.5, bty = "n")

box(lwd = 2)

pair.mean


```


  
  

3) Things to look into...


  --> Does pairwise dissimilarity in composition increase with eDNA content?


